<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>架构笔记 | Freedom</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">架构笔记</h1><a id="logo" href="/.">Freedom</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">架构笔记</h1><div class="post-meta">2021-05-05<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><p><img src="https://blog-1257890402.cos.ap-beijing.myqcloud.com/framework/desktop-share.jpg" alt></p>
<h2 id="一：基础架构"><a href="#一：基础架构" class="headerlink" title="一：基础架构"></a>一：基础架构</h2><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><blockquote>
<p>架构是顶层设计，框架是面向变成或前置的半成品；组件是技术维度上的复用，模块是业务维度上职责的划分；系统是相互协作可运行的实体。</p>
</blockquote>
<h3 id="架构设计的背景"><a href="#架构设计的背景" class="headerlink" title="架构设计的背景"></a>架构设计的背景</h3><blockquote>
<p>随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成的时候，整体系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。</p>
</blockquote>
<p>只有大公司开发的软件系统才具备较大规模，而只有规模较大的软件系统才会面临软件架构相关的问题，例如：</p>
<ul>
<li>系统规模庞大，内部耦合严重，开发效率低；</li>
<li>系统耦合严重，牵一发而动全身，后续修改和跨站困难。</li>
<li>系统逻辑复杂，容易出问题，出问题后很难排查和修复。</li>
</ul>
<h3 id="架构复杂度来源：高性能"><a href="#架构复杂度来源：高性能" class="headerlink" title="架构复杂度来源：高性能"></a>架构复杂度来源：高性能</h3><p>软件系统中高性能带来的复杂度主要体现在两方面。一方面是单台计算机为了内部高性能带来的复杂度；另一方面是多台计算机集群为了高性能带了的复杂度。</p>
<ul>
<li><p>计算机内部复杂度最关键的地方就是操作系统。计算机性能的本质发展商是由硬件发展驱动的，尤其是CPU的性能发展。而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身其实也是跟随硬件的发展而发展的，操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。</p>
<p>操作系统和性能相关的就是进程和线程。</p>
<p>输入指令-&gt;批处理系统-&gt;进程-&gt;线程</p>
</li>
<li><p>集群的复杂度：</p>
</li>
</ul>
<ol>
<li>任务分配：集群</li>
<li>任务分解：将业务服务器按照业务子系统进程拆分。</li>
</ol>
<h3 id="架构复杂度来源：高可用"><a href="#架构复杂度来源：高可用" class="headerlink" title="架构复杂度来源：高可用"></a>架构复杂度来源：高可用</h3><blockquote>
<p>系统无中断的执行其功能的能力，代表系统的可用性程度，是进行系统设计的准则之一</p>
</blockquote>
<p>系统的高可用方案五花八门，但万变不离其宗，本质都是通过“冗余”来实现高可用。</p>
<p>单纯从形式上来看，高可用和高性能一样，都是通过增加更多机器来达到目的。但其实本质上有根本区别：</p>
<p><strong>高性能增加机器的目的在于“扩展”处理性能，高可用增加机器目的在于“冗余”处理单元。</strong></p>
<p><strong>计算高可用</strong></p>
<p>具体表现为：</p>
<ul>
<li>需要增加一个分配器。</li>
<li>任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式并且对连接进行管理。</li>
<li>任务分配器需要增加分配算法。</li>
</ul>
<p><strong>存储高可用：</strong></p>
<p>存储与计算高可用有一个本质的区别：将数据从一台机器搬到另一台机器，需要经过线路进行传输。</p>
<p>但存储高可用的难点不在于如何备份数据，而在于如何减少或者避免不一致对业务造成的影响。</p>
<p>分布式领域里面有一个著名的<strong>CAP</strong>理论，从理论上论证了存储高可用的复杂度。也就是，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多只能满足其中两个。</p>
<p><strong>高可用状态决策</strong></p>
<p>高可用具体时间过程中存在一个本质的矛盾：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。</p>
<p>具体的决策方式：</p>
<ol>
<li><p><strong>独裁式：</strong>存在一个独立的决策主体，称为“决策者”，负责收集信息然后进行决策，所有冗余的个体我们称之为“上报者”，都将状态信都发送给决策者。</p>
<p><strong>缺陷：</strong> 决策者本身出现故障。</p>
</li>
<li><p><strong>协商式：</strong>两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式就是主备决策。</p>
</li>
</ol>
<p>流程：</p>
<ul>
<li><p>2台服务器启动时都是备机。</p>
</li>
<li><p>2台服务器建立连接。</p>
</li>
<li><p>2台服务器交换状态信息。</p>
</li>
<li><p>某一台服务做出决策，成为主机，另一台服务器继续保持备机身份。</p>
<p><strong>缺陷：</strong> 如果两台机器的信息交互出现问题。决策应该怎么做？</p>
</li>
<li><p>如果备机在连接中断的情况下认为主机故障，那么备机需要升级为主机，但实际上此时主机并没有故障，系统会出现两台主机。</p>
</li>
<li><p>如果备机在连接中断的情况下认为主机不故障，但此时如果主机真的发生故障，系统就没有主机。</p>
</li>
<li><p>为了规避连接中断对状态决策带来的影响，可以增加更多的连接。虽然能够降低连接中断对状态带来的影响，但同时又引入了这几条连接之间信息取舍的问题，即如果不同连接传递的信息不同，应该以哪个连接为准？实际上也是无解的问题。</p>
</li>
</ul>
<ol>
<li><strong>民主式：</strong></li>
</ol>
<p>和协商式决策比较类似，其基础都是独立的个体之间交换信息，每个个体做出自己的决策，然后按照“多数取胜”的规则来确定最终的状 态。ZooKeeper采用的选举算法：ZAB。</p>
<p>   <strong>缺陷：</strong> 首先算法复杂，除此之外还有一个固有的缺陷：脑裂。  </p>
<p>假设本身有5个节点，当连接中断的时候，1、2、3形成一个子集群，4、5想成一个子集群，就会出现两个主节点产生脑裂。</p>
<p>一般采用“投票节点数必须超过系统总节点数一半”规则来处理。上述情况4、5就不会参与决策。但如果是真的1、2、3发生节点故障，就会变成无主节点，整个系统就相当于宕机了。</p>
<p><strong><em>总结：</em></strong></p>
<blockquote>
<p>无论采用什么方法，状态决策都不可能做到任何场景下都没有问题，但完全不做高可用又会产生更大的问题，如何选择取舍也是一个复杂的分析、判断和选择的过程。</p>
</blockquote>
<h3 id="架构复杂度来源：可扩展性"><a href="#架构复杂度来源：可扩展性" class="headerlink" title="架构复杂度来源：可扩展性"></a>架构复杂度来源：可扩展性</h3><blockquote>
<p>可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整体系统重构或者重建。</p>
</blockquote>
<p>由于软件系统固有的多变性，新的需求总是不断被提出，因此可扩展性显得尤为重要。软件开发领域，面向对象的思想就是为了解决可扩展性带来的问题，后来的设计模式，更是将可扩展性做到了极致。</p>
<p>两个基本原则：</p>
<p><strong>完美预测变化：</strong></p>
<p>软件系统与硬件系统相比，有一个很大的差异：软件系统在发布后还可以不断的修改和演进，这就意味着不断有新的需求需要实现。如果新的需求能够不改代码或者少改代码就可以实现，那当然是皆大欢喜，否则一个需求就要求系统大改一次，成本会非常高，程序员改来改去不爽，产品经理嫌弃做的慢，老板嫌弃那么多人只能干这么点事！因此作为架构师，就需要试图去预测所有的变化，然后设计完美的方案来应对。</p>
<p>然而现实却是很复杂的，“唯一不变的就是变化”。对于架构师来说，把握预测的程度和提升预测结果的准确性，是一件很复杂的事情，没有标准，更多的是靠经验、直觉。</p>
<p><strong>完美封装变化：</strong></p>
<blockquote>
<p>将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。</p>
</blockquote>
<ul>
<li>系统需要拆分出变化层和稳定层: 不同的渠道接口都是变化层，而本地商品库业务就是稳定层。</li>
<li>需要设计变化层和稳定层之间的接口：对于稳定层来说，接口肯定是越稳定越好，但对于变化层来说，在有差异的多个实现方式中找到共同点，并且还要保证当加入新的功能时原有的接口设计不需要太大修改。这种常见的应对方案就是提炼出一个抽象层和一个实现层。抽象层是稳定的，实现层可以根 据具体业务需要定制开发。</li>
</ul>
<blockquote>
<p>设计可扩展性的系统，有两个思考角度：</p>
</blockquote>
<ul>
<li>业务维度：对业务深入理解，对可预计的业务变化进行预测。</li>
<li>技术维度：利用扩展性好的技术，实现对变化的封装。</li>
</ul>
<h3 id="架构复杂度来源：低成本、安全和规模"><a href="#架构复杂度来源：低成本、安全和规模" class="headerlink" title="架构复杂度来源：低成本、安全和规模"></a>架构复杂度来源：低成本、安全和规模</h3><ul>
<li><strong>低成本</strong></li>
</ul>
<blockquote>
<p>当我们的架构只涉及到几台或者十几台服务器时，一般情况下成本不是我们重点关注的目标，但如果设计的方案设计成百上千上万台服务器，成本就会变成一个非常重要的架构设计考虑点。</p>
</blockquote>
<p>当我们设计高性能、高可用架构时，通用的手段都是增加更多的服务器来满足要求，而低成本正好与此相反，我们需要减少服务器才能达成低成本的目标。</p>
<p>低成本给架构设计带来的主要复杂度体现在：往往只有“创新”才能达到低成本目标。但实际上无论引入新技术还是自己创造新技术，都是一件复杂的事情。</p>
<ul>
<li><strong>安全</strong></li>
</ul>
<blockquote>
<p>安全本身又是一个庞大而又复杂的技术领域</p>
</blockquote>
<ol>
<li>功能安全：XSS攻击、CSRF攻击、SQL注入、Windows漏洞、密码破解等。功能安全其实就是防小偷。从实现角度来看，功能安全更多的是和具体的编码相关，与架构关系不大。</li>
<li>架构安全。如果说功能安全是防小偷，那么架构安全就是防强盗。但目前互联网系统的架构安全目前并没有太好的手段来实现，更多的是依靠运营商或者云服务是强大的宽带和流量清洗的能力，较少自己来设计和实现。</li>
</ol>
<ul>
<li><strong>规模</strong></li>
</ul>
<blockquote>
<p>很多企业级的系统，既没有高性能要求，也没有高可用要求，也不需要什么可扩展性，但有时候一想到这样的系统，很多人都脱口而出：这个系统好复杂。问题的关键在于：功能特别多，逻辑分支特别多。</p>
</blockquote>
<p>规模带来复杂度的主要原因是：量变一起质变。</p>
<p>功能越来越多或者数据越来越多，都会导致复杂度发生质变。</p>
<h3 id="架构设计的三个原则"><a href="#架构设计的三个原则" class="headerlink" title="架构设计的三个原则"></a>架构设计的三个原则</h3><blockquote>
<p>对于编程来说，本质上是不能存在不确定性的，而对于架构来说，本质上是不确定的，同样一个系统，A公司和B公司做出来的架构可能差异很多，但最后都能正常运转。</p>
</blockquote>
<p>业务千变万化，技术层次不穷，设计理念百花齐放，发现几个共性的原则：合适原则、简单原则、演化原则</p>
<p><strong>合适原则：合适优于业界领先</strong></p>
<ul>
<li>没那么多人，却想干那么多活。</li>
<li>没有那么多积累，却想一步登天。</li>
<li>没有卓越的业务场景，却幻想灵光一闪成为天才。业界领先的方案都是被“逼”出来的。</li>
</ul>
<p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理的将资源整合在一起并发挥出最大的功效，并且能够快速落地。</p>
<p><strong>简单原则：简单优于复杂</strong></p>
<p>软件领域的复杂性主要体现在两个方面：</p>
<ul>
<li><strong>结构复杂度</strong></li>
</ul>
<ol>
<li>组件越多，就越有可能其中某个组件出现故障。</li>
<li>某个组件改动，会影响关联的所有组件。</li>
<li>定位一个复杂系统中的问题总是比简单系统更加困难。</li>
</ol>
<ul>
<li><strong>逻辑复杂度</strong></li>
</ul>
<p>意识到结构的复杂度之后，是不是就可以靠“降低组件数量”来解决。毕竟组件数量越少，系统架构越简单。不幸的是，这样做是行不通的。因为除了结构的复杂度，还有逻辑的复杂度，即如果某个组件逻辑太复杂，一样会带来各种问题。以电商为例，如果将商品、订单、支付…全部放到一个组件中实现，就是典型的逻辑复杂性。</p>
<blockquote>
<p>综合来看，无论结构复杂还是逻辑复杂，都会存在各种问题，所以架构设计时如果简单地方案和复杂的方案都可以满足，最好选择简单的方案。</p>
</blockquote>
<p><strong>演化原则：演化优于一步到位</strong></p>
<p>对于软件来说：变化才是主题。软件架构设计其实更加类似于大自然设计一个生物，通过演化让生物适应环境，并逐步变得更加强大。</p>
<h2 id="二：高性能架构"><a href="#二：高性能架构" class="headerlink" title="二：高性能架构"></a>二：高性能架构</h2><h3 id="数据库集群：读写分离"><a href="#数据库集群：读写分离" class="headerlink" title="数据库集群：读写分离"></a>数据库集群：读写分离</h3><blockquote>
<p>读写分离的基本原理是将数据库读写操作分散在不同的节点上</p>
</blockquote>
<p><strong>读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度：</strong></p>
<ul>
<li><strong>主从复制延迟</strong></li>
</ul>
<ol>
<li>写操作后的读操作指定发给主库</li>
<li>读从失败再读一次主机</li>
<li>关键业务读写操作全部指向主机，非关键性业务采用读写分离</li>
</ol>
<ul>
<li><strong>分配机制</strong></li>
</ul>
<ol>
<li>程序代码封装</li>
<li>中间件封装</li>
</ol>
<h3 id="数据库集群：分库分表"><a href="#数据库集群：分库分表" class="headerlink" title="数据库集群：分库分表"></a>数据库集群：分库分表</h3><ul>
<li><strong>业务分库</strong></li>
</ul>
<blockquote>
<p>业务分库是指按照业务模块将数据分散到不同的数据库服务器</p>
</blockquote>
<ol>
<li>join操作问题</li>
<li>事务问题</li>
<li>成本问题</li>
</ol>
<ul>
<li><strong>分表</strong></li>
</ul>
<ol>
<li>垂直分表：将某些不常用但占用了大量空间的列拆出去。</li>
<li>水平分表：水平分表会比垂直分表引入更多的复杂度。</li>
</ol>
<ul>
<li>路由：水平分表后，某条数据具体属于哪个切分后的子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。 join操作：水平分表后，数据分散在多个表中，如果需要与其他表进行join查询，需要在业务代码或中间件中进行join查询，然后将结果合并。 count()操作：某些业务逻辑需要将这些表当做一个表来处理，分表前一个count就可以完成，分表后就没有那么简单，常见的方法：</li>
</ul>
<ol>
<li>count()相加：具体做法是在业务代码或中间件中对每个表进行count操作，然后将结果相加，这种方式简单，但性能较低。</li>
<li>记录数表：新建一张表，包括table_name、row_count两个字段，每次插入或删除子表数据，都更新记录数表。 order by操作：水平分表后，数据分散在多个子表中，排序操作无法再数据库中完成，只能由业务代码或中间件分表查询子表中的数据，然后汇总进行排序。</li>
</ol>
<ul>
<li><strong>实现方法</strong></li>
</ul>
<p>和数据库读写分离类似，分库分表具体的实现方式是：程序代码封装和中间件封装，但实现会更复杂。读写分离只需要识别SQL操作是读还是写，通过简单的几个关键字：SELECT、UPDATE、INSERT、DELETE就可以做到，而分库分表除了要判断类型，还要判断SQL具体操作的表、函数等操作，然后再根据不同的操作进行不同的处理。</p>
<h3 id="高性能NOSQL"><a href="#高性能NOSQL" class="headerlink" title="高性能NOSQL"></a>高性能NOSQL</h3><blockquote>
<p>不能盲目的迷信NOSQL是银弹，而应该将NOSQL作为SQL的一个有力补充。</p>
</blockquote>
<p>常见的NOSQL：</p>
<ul>
<li>K-V存储：Redis</li>
<li>文档数据库：MongoDB</li>
<li>列式数据库：HBase</li>
<li>全文检索：Elasticsearch</li>
</ul>
<h3 id="高性能缓存架构"><a href="#高性能缓存架构" class="headerlink" title="高性能缓存架构"></a>高性能缓存架构</h3><ul>
<li><strong>缓存穿透：</strong></li>
</ul>
<blockquote>
<p>缓存穿透指的是缓存没有发挥作用，业务系统虽然去缓存查询数据，但缓存中没有数据，业务系统需要再次去存储系统查询数据。</p>
</blockquote>
<ul>
<li><strong>缓存雪崩</strong></li>
</ul>
<blockquote>
<p>缓存失效(过期)后引起系统急剧下降。当缓存过期被清除后，业务系统需要重新生成缓存，因此需要再次访问存储系统，再进行运算。</p>
</blockquote>
<p>解决方案：</p>
<p>更新锁：对缓存更新操作后进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取到更新锁的线程要么等待锁释放后重新读取缓存，要么返回空的值或默认值。(分布式锁) 后台更新：不是业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。</p>
<ul>
<li><strong>缓存热点</strong></li>
<li><strong>实现方式</strong></li>
</ul>
<h2 id="三：高可用架构"><a href="#三：高可用架构" class="headerlink" title="三：高可用架构"></a>三：高可用架构</h2><h2 id="四：可扩展架构"><a href="#四：可扩展架构" class="headerlink" title="四：可扩展架构"></a>四：可扩展架构</h2><h2 id="五：实战"><a href="#五：实战" class="headerlink" title="五：实战"></a>五：实战</h2></div><div class="tags"><a href="/tags/java/"><i class="fa fa-tag"></i>java</a><a href="/tags/架构/"><i class="fa fa-tag"></i>架构</a><a href="/tags/分布式/"><i class="fa fa-tag"></i>分布式</a></div><div class="post-nav"><a class="pre" href="/2021/08/20/Spring Data JPA/">Spring Data JPA</a><a class="next" href="/2021/04/03/女子日常/">酷顽音乐 30%女子日常</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/音乐/">音乐</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/unit-test/" style="font-size: 15px;">unit test</a> <a href="/tags/music/" style="font-size: 15px;">music</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/redisson/" style="font-size: 15px;">redisson</a> <a href="/tags/JPA/" style="font-size: 15px;">JPA</a> <a href="/tags/ORM/" style="font-size: 15px;">ORM</a> <a href="/tags/lock/" style="font-size: 15px;">lock</a> <a href="/tags/thread/" style="font-size: 15px;">thread</a> <a href="/tags/tidb/" style="font-size: 15px;">tidb</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/u2/" style="font-size: 15px;">u2</a> <a href="/tags/rabbitmq/" style="font-size: 15px;">rabbitmq</a> <a href="/tags/websocket/" style="font-size: 15px;">websocket</a> <a href="/tags/陈无二/" style="font-size: 15px;">陈无二</a> <a href="/tags/蒸汽波/" style="font-size: 15px;">蒸汽波</a> <a href="/tags/布仁巴雅尔/" style="font-size: 15px;">布仁巴雅尔</a> <a href="/tags/tech/" style="font-size: 15px;">tech</a> <a href="/tags/management/" style="font-size: 15px;">management</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/21/Java单元测试/">Java Unit Test</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/20/Redisson/">Redisson</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/20/Spring Data JPA/">Spring Data JPA</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/05/架构笔记/">架构笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/03/女子日常/">酷顽音乐 30%女子日常</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/22/管理小记/">管理小记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/19/蒙太奇旅行/">酷顽音乐 蒙太奇旅行</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/15/Synchronized/">Synchronized关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/ThreadLocal/">ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/15/JVM/">JVM</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Freedom.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>